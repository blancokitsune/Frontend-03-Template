# 学习笔记

## 一个动作的生命周期

我们从人的角度出发，动作理应分为**瞬时动作**和**持续动作**，其中的**持续动作**就需要一些属性来进行描述，大概如下

- **瞬时动作**：点击，触碰，...
- **持续动作**：划过，双击，···

其中，**持续动作**理应不会脱离瞬时动作，它是应该始于某个瞬间时动作，依照某些轨迹去完成接下来的一系列组合动作，在这期间大概可以用以下属性进行描述：

1. 动作抬手时间(start-time)
2. 动作类型(movement-type)
3. 动作力度(movement-intensity)
4. 动作角度(movement-angle)
5. 动作速度(movement-speed)
6. 动作结束时间(end-time)
7. ······

一般有了这些声明，就可以叙述(记录)一个完整的动作(运动轨迹)



## 手势动作的封装实现

主要分为两个大的平台，PC & 移动端，针对PC的**`MouseEvent`** 和移动端的**`TouchEvent`**进行相关封装

### 相关手势操作

接下来针对两种平台，大概列举一些常用的手势操作，其中每个平台都有可能出现**单键/多键**操作，不重复补充

#### PC

1. 点击
2. 按住滑动
3. ······

##### 移动端([相关操作点击此处查看TouchGestureGuide](https://github.com/blancokitsune/Frontend-03-Template/tree/master/week15/TouchGestureGuide.pdf))

1. 触碰/点击(`tap`，瞬时)
2. 小移动事件(`pan`，持续)
3. 按压(`press`，持续)
4. 滑动(`swipe`，持续)
5. ······

### API

有几个 `web api`是处理相关事件的

1. **`GestureEvent`**
2. **`TouchEvent`**
3. **`MouseEvent`**

鉴于通用性等原因，选择其中的`touch`和`mouse`，程序角度我们大致实现三个模块：

1. 监听事件的模块(`Listener`)
2. 记录动作过程的模块(`Recognizer`)
3. 对监听到的动作进行派发的模块(`Dispatcher`)

大概的动作思路其实上面已经写了，剩下的就是去记录相关属性和值来进行判断当前操作类型(点击/划过/轻弹···)

监听事件就去把每个持续动作的起始进行一个监听，之后在每一个你觉得应该是新的转变时进行相关的事件判断/注册

其中最细节的地方应该就是判断**速度**等地方，可以抄一抄成熟的方案